<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">  <head>    <meta http-equiv="Content-Type" content="text/html charset=iso-8859-1" />    <meta name="generator" content="vim" />    <meta name="author" content="Chris Lumens" />     <title>screen - The Terminal Multiplexer</title>     <style type="text/css">       tt { background-color: gray ; color: white }    </style> </head> <body>  <h1>screen - The Terminal Multiplexer</h1> <p>by Chris Lumens<br />March 24, 2004</p>  <div>    <br /><br /> </div>  <h1>What is screen?</h1> <p> <i>screen</i> is a terminal multiplexer: it takes many different running processes and manages which of them gets displayed to the user.  Think of it as a window manager for your console or terminal emulator.  With <i>screen</i>, you can have interactive processes running on your home computer and connect to them from anywhere else to check on their progress.  What sorts of programs are good for running in <i>screen</i>? </p>  <ul>    <li>movie downloads</li>    <li>command line mail clients</li>    <li>log watching</li>    <li>giant compiles (kernel, make World, etc)</li> </ul>  <h1>Terminology</h1> <p> There are three different ways you can think about what <i>screen</i> is displaying to your console.  We'll need to be familiar with the meaning of these terms for the rest of the presentation: </p>  <ul>    <li><b>session</b> - A session is created when you start a new instance       of <i>screen</i> on the command line.  Within a session, you can have       multiple programs running.  A single session can hold many windows.</li>    <li><b>window</b> - Windows are created inside a session, and manage       the running programs.  By default, a single new window is created       when you start up <i>screen</i> to display the running program (for       example, a shell).  You can create many windows within a single       session and quickly switch between them.</li>    <li><b>region</b> - A region is a part of the current window.  When you       do a split, you are creating two different regions within the same       window.  Each region can then display a different program.</li> </ul>  <p> Additionally, it helps to know what the following mean: </p>  <ul>    <li><b>detach</b> - Detaches the currently running program from the       terminal.  From the user's perspective, the running program simply       disappears and the user is dumped back to a shell prompt outside       <i>screen</i> management.  However, all programs being managed by       <i>screen</i> continue to run.</li>    <li><b>attach</b> - Attach to a previously detached program.  This will       bring the program running under the detached session back to the       user's terminal, as if you were watching it the whole time.</li> </ul>  <h1>The Basics</h1>  <h2>Commanding screen</h2> <p> <i>screen</i> tries to stay out of your way as much as possible.  Just about everything you type gets sent to the running program.  This makes interacting with <i>screen</i> a little bit weird.  All <i>screen</i> commands begin with control-a, which will be abbreviated with <tt>^A</tt>. Anything you're supposed to type will be shown in the white-on-grey scheme.  After you give it the <tt>^A</tt>, you give a command key which tells <i>screen</i> what to do.  <tt>^A ?</tt> brings up a list of all the possible commands, while <tt>^A :</tt> brings up a command prompt that you can use to type commands and set variables.  All the command keys have a full word equivalent that you can type. </p>  <h2>Making New Sessions</h2> <p> You make a new session on the command line.  Without any options, <i>screen</i> will make a new session and run your $SHELL inside it: </p>  <div> <code>    $ screen </code> </div>  <p> This session will be named with the PID, TTY, and hostname where the session was started.  Not very descriptive or exciting.  Luckily, you can easily give the session a name: </p>  <div> <code>    $ screen -S edonkey </code> </div>  <p> If you start up a <i>screen</i> session and forget to give it a name, don't worry.  You can use <tt>^A :sessionname &lt;name&gt;</tt> to give it a name. Note that the session names have nothing to do with window names, as we will see later.  Finally, you can have <i>screen</i> start a program other than $SHELL with the common option: </p>  <div> <code>    $ screen -e pine </code> </div>  <h2>Detaching</h2> <p> So you're sitting there recompiling your distribution when you see it's time to run to class.  You'd like to be able to check out the progress later from a lab.  Luckily, you started the compile up in a <i>screen</i> session.  To be able to attach to it later, you first need to detach from it here, with <tt>^A d</tt>.  The compile session will disappear, and you'll be back at the prompt that you started <i>screen</i> from. </p>  <p> There are ways to attach to a running <i>screen</i> session you forgot to detach from.  Those will be covered later. </p>  <h2>Attaching</h2> <p> The opposite operation from detaching is attaching, which is where you reconnect to a previously detached session.  If you've only got one session running, it's very easy to attach to it: </p>  <div> <code>    $ screen -r </code> </div>  <p> However, it's possible that you have many sessions running at once.  In that case, you'll need to tell <i>screen</i> which session to attach to.  Of course, first you will want to know what the possibilities are.  Luckily, <i>screen</i> has a command line option to list running sessions: </p>  <div><pre> <code>    $ screen -ls    There are screens on:         15150.uml-slk   (Detached)         18614.uml-fed   (Detached)    2 Sockets in /tmp/screens/S-root. </code> </pre></div>  <p> Then you just specify the name or PID of the session after the -r command line option and that session will be attached.  You can see why you might want to name things beforehand, especially if you have lots of stuff running. </p>  <h1>Working Within a Session</h1> <p> Running several sessions is handy but switching among them can be a pain, since you have to detach and reattach all the time.  A better option is to run a single session with several windows inside it.  As you'll see, switching among many windows is very quick and powerful. </p>  <h2>New Windows</h2> <p> Making a new window is easy.  Just hit <tt>^A c</tt>.  <i>screen</i> will start up a new active window and run $SHELL in it.  Your previously active window will be hidden from you, but any programs on it are still running.  If you detach a session with many windows in it, all programs on all windows will continue running.  When you reattach, the active window will be displayed again. </p>  <h2>Managing Windows</h2> <p> The most difficult thing about lots of windows is keeping track of them. The default display doesn't show you anything about what windows are open or what programs are running in them.  When you switch from one window to another, the previous one just disappears.  Luckily, <i>screen</i> provides many ways to keep track of all your windows. </p>  <p> Windows can have names, just like sessions.  The default window name is the program running in it, which will usually be $SHELL.  Renaming windows will help you keep track of them, and is done with <tt>^a A</tt>. <i>screen</i> will display a prompt at the bottom for you to provide a name. </p>  <p> A simple way to list all your windows is <tt>^A w</tt>, which just gives you all the names and window number along the bottom of the screen.  This line also displays some status information, the most important being that the current window is marked with an asterisk.  This is just a list, though; there's no way to switch.  If you want to pick from a list, you can use <tt>^A "</tt>, arrow down to the window you want, and hit return. Or if you know the window number, <tt>^A 0-9</tt> will bring that window up.  As we'll see later, there's a way to have a continuous window list display.  This combined with switching on a number is the fastest way to move around. </p>  <h2>Managing Regions</h2> <p> Finally, you've got screen regions.  Just like vim can split the display up into several areas, so can <i>screen</i>.  You can split the window up into two equally sized regions with <tt>^A S</tt>.  The already running program will get squashed into a region half its original size, and a new region will open up on the other half.  This new region will have nothing running in it, since you might want to stick one of your currently running windows inside it. </p>  <p> There's several ways to change focus among regions, but the simplest is the obvious <tt>^A &lt;tab&gt;</tt>  Once you're in the new region, you can display any of your windows in that region just by switching to them with <tt>^A 0-9</tt>, or you can create a new shell in that region with <tt>^A c</tt>. </p>  <p> And last, you might get tired of all these regions clogging up your window and want to kill them.  You can make the current region the only visible one with <tt>^A Q</tt>, which simply hides all the other regions and makes them accessible via the window numbers.  Or, you can kill off the current region entirely with <tt>^A X</tt>.  Note that hiding a region keeps programs running, while killing a region kills any programs running in it. </p>  <h1>Quitting screen</h1> <p> <i>screen</i> quits when everything running inside it quits.  This means you'll need to step through all your windows and kill the shells running inside them with <tt>^D</tt> or <tt>exit</tt>.  Usually, this is exactly what you want. Sometimes, though, you might want <i>screen</i> to just go away immediately. <tt>^A ^\</tt> will kill <i>screen</i>, and everything running underneath it. That means all the shells running on all the windows, and all the processes started by all those shells.  That's certainly not a command you want to use too often. </p>  <h1>Advanced Topics</h1>  <h2>Attaching</h2> <p> Sometimes, you might be at a remote location and want attach to a session that you'd forgotten to detach from earlier.  You're not out of luck, because <i>screen</i> provides you a couple ways to handle this situation.  The first approach is: </p>  <div> <code>    $ screen -x src </code> </div>  <p> This attaches to the <b>src</b> session without detaching first.  So in other words, you've got two sessions looking at exactly the same thing. Anything you do on one session will be displayed on all of them.  When you're done, detaching from the one session leaves the other attached.  It helps to have the same terminal type and size to do this, though. </p>  <p> You can also use one of the six -D -R option combinations described in the <i>screen</i> man page to detach any active sessions before attaching again. </p>  <h2>Digraphs</h2> <p> Digraphs are characters that take us several keystrokes to type, because our keyboard doesn't have the right symbols.  Good examples are European letters and international money symbols, like ë, ø, and Æ.  X supports these characters with the compose key, which you can map to any spare key you've got on your keyboard.  <i>screen</i> provides similar functionality with the digraph command.  Just type <tt>^A ^V</tt> followed by the characters that make up the digraph.  The three characters I made above are done with: </p>  <ul>    <li>ë = <tt>^A ^V e :</tt></li>    <li>ø = <tt>^A ^V o /</tt></li>    <li>Æ = <tt>^A ^V A E</tt></li> </ul>  <p> <i>screen</i>'s digraph list is built-in, so you can't yet add your own.  Note that <tt>^V</tt> is also the vim insert mode command that allows you to put control sequences into your files. </p>  <h2>Monitoring</h2> <p> Say you've got a whole bunch of windows open.  One of those windows is idling in a very inactive IRC channel.  Since not much goes on in there, you don't keep that window active but you would like to know when something is said. <i>screen</i> lets you monitor any window for activity by first switching to the window, and then hitting <tt>^A M</tt>.  When activity in that window occurs, <i>screen</i> will display a message at the bottom. </p>  <p> On the other hand, say one of your windows is a compile of X.  There's lots and lots of activity and you'd like to know when the build is finished.  You can monitor for 30 seconds of inactivity by switching to the window and hitting <tt>^A _</tt>.  When the window goes silent, <i>screen</i> will display a message at the bottom. </p>  <p> These monitoring commands are toggles, so you can turn them off by switching to any monitored window and issuing the command again. </p>  <h2>Nested screens</h2> <p> Yes, it is possible to have <i>screen</i> sessions inside each other.  This can be really confusing, so I'm only mentioning it so you know it's possible.  One problem with nested <i>screen</i>s is sending the <tt>^A</tt> to one of the nested sessions, since the most outside session will interpret the key and not send it where you wanted.  In this case, you need <tt>^A a</tt> which simply sends <tt>^A</tt> to the running program, which might just be another <i>screen</i>.  If you had one <i>screen</i> inside another and wanted a list of windows on the inner one, you'd need to do <tt>^A a w</tt>. </p>  <h2>Multiple Users</h2> <p> Finally, <i>screen</i> allows several users to connect to a single session at the same time.  It provides an access list for the session and allows you to set read/write/execute permissions for each user on that list.  It even provides a way to set up user groups.  One good reason for this multiple user feature is that you can interactively have several people looking at some source code so there's no confusion as to what part you're talking about. </p>  <p> Before anyone else can connect to your <i>screen</i> sessions, you have to enable multiuser mode with <tt>^A :multiuser on</tt>.  Then, you give another user permission to connect with <tt>^A :aclchg david +r "#"</tt>.  This means that the system user has read permission on all windows.  You can specify multiple users, write and execute permissions, and certain windows.  Be especially careful with the execute permission as that will let other people create new windows and change the acl permissions themselves. </p>  <p> Now the user you granted access to can connect with: </p>  <div> <code>    $ screen -r chris/ </code> </div>  <p> At any time, you can delete other users with <tt>acldel david</tt>.  As with any system that involves multiple users, there are a lot of security implications and access features.  Use carefully and see the man page for the details. </p>  <h1>Customization with $HOME/.screenrc</h1> <p> /etc/screenrc and $HOME/.screenrc are the <i>screen</i> configuration files, with the $HOME one overriding values set in the global one.  You can experiment with settings while <i>screen</i> is running, and then move those settings into your .screenrc file to make them permanent.  Just about anything you can type into <i>screen</i> can be added to the config file.  I'm only going to touch on a few.  See the man page for more. </p>  <h2>Visual Bell</h2> <p> Instead of beeping, the visual bell displays a message when something happens. The default <i>screen</i> message is "   Wuff  ----  Wuff!!  ", which is pretty stupid.  You can change this with the following line: </p>  <div> <code>    vbell_msg "beep" </code> </div>  <h2>Key Bindings</h2> <p> You can add your own commands that are bound to keys.  For example, here's an example key binding that opens a new window with an ssh session to a different computer: </p>  <div> <code>    bind 'R' screen ssh root@foc-gw-1 </code> </div>  <p> Now hitting <tt>^A R</tt> will open up a new window with an ssh session in it. As you can see, you still need to hit <tt>^A</tt> to get <i>screen</i> to pay attention.  Key bindings can get way more complicated than this, of course. </p>  <h2>Terminal Hacks</h2> <p> <i>screen</i> lets you modify the termcap entry without having to make up an entire new one by hand.  I'm not really going to cover this, except to mention it.  I don't really understand all the termcap stuff so I can't talk about it too much.  But if you know that you need to edit the terminal settings, <i>screen</i> will let you do that.  Here's an example out of the system default: </p>  <div> <code>    termcap  vt100 dl=5\E[M </code> </div>  <h2>Startup Windows</h2> <p> You can specify all sorts of windows to start up when you run <i>screen</i>. Just list them in your .screenrc file with the <tt>screen</tt> command, like so: </p>  <div><pre> <code>    screen 0 ssh chris@ziggy -e pine    screen 1 vim ~/src/manos/src/kern/GNUmakefile    screen 2 ssh -X root@unit </code> </pre></div>  <h2>Fancy Status Line</h2> <p> Earlier, I mentioned that you could have a constant display of what windows are open, to make switching between them faster.  You do this with the hardstatus line.  By default, status goes up into the titlebar of an xterm, or down at the bottom of the screen on the console.  However, you can force that status line to always stay at the bottom of the screen by adding this to your .screenrc: </p>  <div><pre> <code>    hardstatus on    hardstatus alwayslastline </code> </pre></div>  <p> Then you just need to set up a statusline string that displays the information you want.  The following statusline displays a list of all the windows and their numbers on the left side, and the date and time on the right side: </p>  <div> <code>    hardstatus string "%w%=%m/%d %c" </code> </div>  <p> Of course, these status lines can get much more complicated including colors, output of random programs, and so forth.  See the man page section "STRING ESCAPES" for details. </p>  <h1>Conclusion</h1> <p> <i>screen</i> is a complex and powerful program for managing interactive console programs, similar to how a window manager handles graphical programs. <i>screen</i> is more powerful than a window manager, though, because it allows you to attach and detach from the running programs as much as you want.  I've only covered a few of its many features in this presentation.  The man page is far more detailed. </p>  <p> This presentation is available at <a href="http://www.bangmoney.org/presentations/screen.html">http://www.bangmoney.org/presentations/screen.html</a> and is &copy; 2004 Chris Lumens. </p>  </body> </html> 
